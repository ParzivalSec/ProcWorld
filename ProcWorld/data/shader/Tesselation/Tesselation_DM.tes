#version 430 core

/**
- triangles: Domain the PG will work on, can also be quad or isoline
- equal_spacing: triangel edges will be subdivided into segments with euqal lengths
- ccw: PG will emit triangles in counter-clockwise order (cw for clockwise)

**/

// TES cann access the entire TCS output patch

layout(triangles, equal_spacing, ccw) in;

uniform mat4 view;
uniform mat4 projection;
uniform sampler2D displacementMap;
uniform float displacementFactor;

in ControlPointData
{
	vec3 position;
	vec3 normal;
	vec2 texCoord;
} controlPointData[];

out VertexData
{
	vec3 position;
	vec3 normal;
	vec2 texCoord;
} tesselationVertex;

vec2 interpolate2D(vec2 v0, vec2 v1, vec2 v2)
{
   	return vec2(gl_TessCoord.x) * v0 + vec2(gl_TessCoord.y) * v1 + vec2(gl_TessCoord.z) * v2;
}

vec3 interpolate3D(vec3 v0, vec3 v1, vec3 v2)
{
   	return vec3(gl_TessCoord.x) * v0 + vec3(gl_TessCoord.y) * v1 + vec3(gl_TessCoord.z) * v2;
}

void main()
{
	// Interpolate the data of the Control Points provided based on the barycentric coordinates which can be seen as wights in a triangle
	tesselationVertex.texCoord = interpolate2D(controlPointData[0].texCoord, controlPointData[1].texCoord, controlPointData[2].texCoord);
	tesselationVertex.normal = interpolate3D(controlPointData[0].normal, controlPointData[1].normal, controlPointData[2].normal);
	tesselationVertex.normal = normalize(tesselationVertex.normal);
	tesselationVertex.position = interpolate3D(controlPointData[0].position, controlPointData[1].position, controlPointData[2].position);
	
	// Add displacement to the vertex
	float displacement = texture2D(displacementMap, tesselationVertex.texCoord.xy).x;
	tesselationVertex.position += tesselationVertex.normal * displacement * displacementFactor;
	
	gl_Position = projection * view * vec4(tesselationVertex.position, 1.0f);
}